버킷정렬 (좀 더 최적화시킨 버전)

0. 전반적인 메소드 이름은 AdaptiveBucketSort로 한다.

1. 함수의 인자로 정렬할 배열과 시작지점, 끝지점, 버킷 크기를 받는다.

2. 주어진 배열 안에서 최댓값을 구해서 별도의 변수에 초기화한다. (별도의 함수 내에서 구할 것)

3-1. 최솟값이 0이라 가정하고 버킷의 개수를 (최댓값/버킷 크기) + 2로 구한다.
(어차피 분포에 의한 정렬은 음이 아닌 정수만 정렬이 가능하므로)
3-2. 버킷 오프셋 배열을 버킷 개수만큼 초기화한다.
3-3. 오프셋 보조 배열 역시 버킷 개수만큼 초기화한다. (오프셋에서 얼마만큼 떨어진 곳에 덮어쓸지 결정하는 배열)

4-1. 시작지점부터 끝지점까지의 정렬되지 않은 배열요소를 추가 배열에 차례대로 쓴다. (auxwrites == true)
4-2. 버킷 오프셋의 크기를 구하기 위해 4-1이 실행되고 난 이후 오프셋 배열의 (현재 배열요소)/(버킷 크기) + 1번째 요소를 1씩 증가시킨다.

5. 오프셋 배열의 1번째 요소부터 앞의 배열요소를 차례로 더하는 과정을 수행한다.
(그래야 제대로 된 버킷 시작 위치를 알 수 있으니까)

6-1. 메인 배열의 (오프셋 배열의 (추가 배열의 i번째 배열요소/버킷 크기))번째 요소를 추가 배열의 i번째 배열요소로 덮어쓴다.
(i는 계속 증가시키고 auxwrites == false)
6-2. 해당 버킷의 오프셋 보조 배열의 값을 1씩 증가시킨다.

7-1. 버킷 크기가 16 이하라면 배열 전체를 삽입정렬하고 알고리즘을 끝낸다.
7-2. 나머지 경우 8번으로 간다.

8. 버킷 크기가 17 이상일 때 이 과정을 거친다.
8-1. 각각 분류된 버킷을 계수정렬로 완전히 정렬할 텐데 이 과정을 별도의 함수로 마련한다.
(재귀적인 방법을 사용했을 경우 무슨 이유인지 모르겠지만 java.lang.ArrayIndexOutOfBoundsExeption이 나온다..)
(이 함수 이름은 MiniCountingSort로 한다)
8-2. 여기서는 최댓값과 최솟값을 모두 받는다. (최솟값 역시 별도의 함수 내에서 구할 것)

9. 정렬 끝.

최선/평균/최악 시간복잡도 O(n), 공간복잡도 O(n)